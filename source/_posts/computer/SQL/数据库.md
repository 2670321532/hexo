---
title: 数据库
date: 2021/2/8 11:23:35
comments: true
tags: 
- 数据库
- 范式
categories: 
- 计算机
- 数据库
---

# 数据库三范式

国内绝大多数院校用的王珊的《[数据库系统概论](https://www.zhihu.com/search?q=数据库系统概论&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})》这本教材，某些方面并没有给出很详细很明确的解释，与实际应用联系不那么紧密，你有这样的疑问也是挺正常的。我教《[数据库原理](https://www.zhihu.com/search?q=数据库原理&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})》这门课有几年了，有很多学生提出了和你一样的问题，试着给你解释一下吧。（基本来自于我上课的内容，某些地方为了不过于啰嗦，放弃了一定的严谨，主要是在“关系”和“表”上）

首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为**一张数据表的表结构所符合的某种设计标准的级别**。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。[数据库范式](https://www.zhihu.com/search?q=数据库范式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计[关系型数据库](https://www.zhihu.com/search?q=关系型数据库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。

接下来就对每一级范式进行一下解释，首先是**第一范式（1NF）。**

符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于[面向对象程序设计](https://www.zhihu.com/search?q=面向对象程序设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。**1NF的定义为：符合1NF的关系中的每个属性都不可再分。表1**所示的情况，就不符合1NF的要求。

![](../images/Database/1.png)

实际上，**1NF是所有关系型数据库的最基本要求**，你在关系型[数据库管理系统](https://www.zhihu.com/search?q=数据库管理系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为**表2**的形式：

![](../images/Database/2.png)

但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于**表3**中的设计：

![](../images/Database/3.png)



1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——**数据冗余过大** 

2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——**插入异常**

   注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。

   注２：**码：关系中的某个属性或者某几个属性的组合，用于区分每个[元组](https://www.zhihu.com/search?q=元组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})**（可以把“元组”理解为一张表中的每条记录，也就是每一行）**。**

3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——**删除异常**

4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——**修改异常**。

正因为仅符合1NF的[数据库设计](https://www.zhihu.com/search?q=数据库设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。

**第二范式（2NF）**在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。接下来对这句话中涉及到的四个概念——**“函数依赖”**、**“码”**、**“非主属性”**、与**“部分函数依赖”**进行一下解释。

**函数依赖**
我们可以这么理解（但并不是特别严格的定义）：**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说**姓名函数依赖于学号**，写作 **学号 → 姓名**。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：

- 系名 → 系主任
- 学号 → 系主任
- （学号，课名） → 分数

但以下函数依赖关系则不成立：

- 学号 → 课名
- 学号 → 分数
- 课名 → 系主任
- （学号，课名） → 姓名

从“函数依赖”这个概念展开，还会有三个概念：

**[完全函数依赖](https://www.zhihu.com/search?q=完全函数依赖&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})**

在一张表中，若 X → Y，且对于 X 的任何一个[真子集](https://www.zhihu.com/search?q=真子集&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**，记作 X F→ Y。（那个F应该写在箭头的正上方，没办法打出来……，正确的写法如**图1**）

![](../images/Database/4.png)

例如： 

- 学号 F→ 姓名 
- （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）

**部分函数依赖**

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y，如**图2**。

![](../images/Database/5.png)

例如：

- （学号，课名） P→ 姓名 



**传递函数依赖**
假如 Z 函数依赖于 Y，且 Y 函数依赖于 X

(『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，如**图3**。

![](../images/Database/6.png)

**码**
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**） 

例如：
对于表3，**（学号、课名）**这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）

**非主属性**
包含在任何一个码中的属性成为主属性。

例如：
对于表3，主属性就有两个，**学号** 与 **课名**。



终于可以回过来看2NF了。首先，我们需要判断，表3是否符合2NF的要求？根据2NF的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：

第一步：找出数据表中所有的**码**。
第二步：根据第一步所得到的码，找出所有的**主属性**。
第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
第四步：查看是否存在非主属性对码的**部分函数依赖**。

对于表3，根据前面所说的四步，我们可以这么做：

第一步：

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“**完全**函数依赖”）。

**图4**表示了表中所有的函数依赖关系：

![](../images/Database/7.png)

这一步完成以后，可以得到，表3的码只有一个，就是**（学号、课名）**。

第二步：
主属性有两个：**学号** 与 **课名**



第三步：
非主属性有四个：**姓名**、**系名**、**系主任**、**分数**



**第四步：**
对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性  对码**（学号，课名）**的部分函数依赖。

所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。





为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：
选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）

我们先来判断以下，**选课**表与**学生**表，是否符合了2NF的要求？

对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

**图5**表示了[模式分解](https://www.zhihu.com/search?q=模式分解&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})以后的新的函数依赖关系

![](../images/Database/8.png)

表4表示了模式分解以后新的数据

![](../images/Database/9.png)

表4

（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1. 李小明转系到法律系
   只需要修改一次李小明对应的系的值即可。——有改进
2. 数据冗余是否减少了？
   学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
3. 删除某个系中所有的学生记录
   该系的信息仍然全部丢失。——无改进
4. 插入一个尚无学生的新系的信息。
   因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于码**学号**的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。

**[第三范式](https://www.zhihu.com/search?q=第三范式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})（3NF）** **3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

接下来我们看看表4中的设计，是否符合3NF的要求。

对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名，**非主属性只有一个，为分数，不可能存在[传递函数](https://www.zhihu.com/search?q=传递函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})依赖，所以**选课**表的设计，符合3NF的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。。

为了让[数据表设计](https://www.zhihu.com/search?q=数据表设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A29189700})达到3NF，我们必须进一步进行模式分解为以下形式：
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）

对于**选课**表，符合3NF的要求，之前已经分析过了。

对于**学生**表，码为**学号**，主属性为**学号**，非主属性为**系名**，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。

对于**系**表，码为**系名**，主属性为**系名**，非主属性为**系主任**，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。



新的函数依赖关系如图6

![](../images/Database/10.png)

新的数据表如表5

![](../images/Database/11.png)

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1. 删除某个系中所有的学生记录
   该系的信息不会丢失。——有改进
2. 插入一个尚无学生的新系的信息。
   因为系表与学生表目前是独立的两张表，所以不影响。——有改进
3. 数据冗余更加少了。——有改进



**结论**
由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。

==============时隔半年，终于决定把这个坑填上，来晚了 ===========

**BCNF范式**

要了解 BCNF 范式，那么先看这样一个问题：

若：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![](../images/Database/12.png)

好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

以上就是关于 BCNF 的解释。

**问题1：**

关于码的定义，如果除K之外的所有属性都完全函数依赖于K时才能称K为码，那么在判断2NF时又怎么会存在非主属性对码的部分函数依赖这种情况？

我 ：在“码”的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。

比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F= {
Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }

那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno / Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。

所以可得到主属性：Sno, Cno
非主属性：Sname, Cname, Sdept, Sloc, Grade

R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。

========================================

# mysql索引使用

![](../images/Database/13.png)

索引是快速搜索的关键。MySQL索引的建立对于MySQL的高效运行是很重要的。下面介绍几种常见的MySQL索引类型。
 在数据库表中，对字段建立索引可以大大提高查询速度。假如我们创建了一个 mytable表：

```csharp
create table mytable(  
  id  int not null,   
  username varchar(16) not null 
);  
```

```
flask 中 models.py中使用
		    name   值
db.Index("a_b_key",a,b)
```

我们随机向里面插入了10000条记录，其中有一条：5555, admin。
 在查找username="admin"的记录 SELECT * FROM mytable WHERE username='admin';时，如果在username上已经建立了索引，MySQL无须任何扫描，即准确可找到该记录。相反，MySQL会扫描所有记录，即要查询10000条记录。
 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
 MySQL索引类型包括：
 （1）普通索引
 这是最基本的索引，它没有任何限制。它有以下几种创建方式：
 ◆创建索引
 `CREATE INDEX indexName ON mytable(username(length));`
 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。
 ◆修改表结构
 `ALTER mytable ADD INDEX [indexName] ON (username(length)) ;`
 ◆创建表的时候直接指定

```cpp
CREATE TABLE mytable(  
  ID INT NOT NULL,   
  username VARCHAR(16) NOT NULL,  
  INDEX [indexName] (username(length))  
);  
```

删除索引的语法：
 `DROP INDEX [indexName] ON mytable;`
 （2）唯一索引
 它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：
 ◆创建索引
 `CREATE UNIQUE INDEX indexName ON mytable(username(length))`
 ◆修改表结构
 `ALTER mytable ADD UNIQUE [indexName] ON (username(length)) ;`
 ◆创建表的时候直接指定

```cpp
CREATE TABLE mytable(  
   ID INT NOT NULL,    
   username VARCHAR(16) NOT NULL,  
   UNIQUE [indexName] (username(length))  
 );  
```

（3）主键索引
 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：

```cpp
CREATE TABLE mytable(  
  ID INT NOT NULL,   
  username VARCHAR(16) NOT NULL,  
  PRIMARY KEY(ID)  
 );  
```

当然也可以用 ALTER 命令。记住：一个表只能有一个主键。
 （4）组合索引
 为了形象地对比单列索引和组合索引，为表添加多个字段：

```cpp
CREATE TABLE mytable(  
   ID INT NOT NULL,    
   username VARCHAR(16) NOT NULL,   
   city VARCHAR(50) NOT NULL,  
   age INT NOT NULL
 );  
```

为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：
 `ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);`
 建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。
 如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。
 建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

```undefined
usernname,city,age   
usernname,city  
usernname  
```

为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：

```bash
SELECT FROM mytable WHREE username="admin" AND city="郑州"
SELECT FROM mytable WHREE username="admin"
```

而下面几个则不会用到：

```bash
SELECT FROM mytable WHREE age=20 AND city="郑州"
SELECT FROM mytable WHREE city="郑州"
```

（5）建立索引的时机
 到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢？一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。例如：

```bash
SELECT t.Name FROM mytable t LEFT JOIN mytable m  ON t.Name=m.username WHERE
m.age=20 AND m.city='郑州';
```

此时就需要对city和age建立索引，由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。
 刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。例如下句会使用索引：
 `SELECT FROM mytable WHERE username like 'admin%'`
 而下句就不会使用：
 `SELECT FROM mytable WHEREt Name like '%admin'`

因此，在使用LIKE时应注意以上的区别。
 （6）索引的不足之处
 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：
 ◆虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
 ◆建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。
 （7）使用索引的注意事项**
 使用索引时，有以下一些技巧和注意事项：
 ◆索引不会包含有NULL值的列
 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
 ◆使用短索引
 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
 ◆索引列排序
 MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
 ◆like语句操作
 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
 ◆不要在列上进行运算
 `select from users where YEAR (adddate)<2007;`

将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成
 `select from users where adddate<‘2007-01-01’;`

◆不使用NOT IN和<>操作
 以上，就对其中MySQL索引类型进行了介绍。

```
1. 分析需求
2. 编写代码
3. 编写单元测试
4. 自测
5. 编写接口文档
6. 提测代码


1. 发送短信服务

容联云  云通讯
www.yuntongxun.com

2. redis文档
http://redis-py.readthedocs.io/en/latest/#indices-and-tables
http://redisdoc.com/index.html


3. 图片服务

1）保存到程序本地，扩容（磁盘满的问题）
2）备份的问题
3）多机存储的问题
4） 用户A    图片A
    用户B    图片B
    图片A 与 图片B 是同一张图片，会保存两次，浪费空间

5）用户A     a.jpg
   用户B     a.jpg
   同名图片，但不是同一张，后上传的会覆盖掉之前的内容


文件存储解决方案：
1） 自己搭建文件存储系统   FastDFS  快速分布式文件存储系统   HDFS  Hadoop分布式文件系统
2） 选择第三方服务   七牛云存储   www.qiniu.com


4. 前端js模板 art-template
https://aui.github.io/art-template/zh-cn/index.html

5. 数据库优化：

a. 表结构设计  扩展  查询的快慢
    三范式  https://www.zhihu.com/question/24696366
    设计的时候就考虑可能会用到的查询，为方便查询而设计，比如用空间换时间，适当增加冗余字段节省查询开销

b. 建索引   主键  唯一(unique)  索引(key   index)  （外键）
    http://www.jianshu.com/p/2b541c028157
    提升 查询速度  复合索引  where k1     k2   k3  k4
    降低   增删改

c. sql语句优化
    使用索引 注意关键字顺序 最左原则  where

    不要select *

    能使用联合查询，不使用嵌套（子查询）

    select  from tbl_a a inner join tbl_b b on a.field=b.filed where b.=

    select from tbl_a where filed=(select field from tbl_b where b.=)

    能不使用联合查询，尽量不用联合查询

    外键 cascade 级联 （维护外键有额外开销，影响性能）  数据量大的时候，不再使用外键

    使用分析工具分析效率低的sql语句   慢查询工具
    https://flyerboy.github.io/2016/12/23/mysql_slow/
    https://yemengying.com/2016/05/24/mysql-tuning/

d. 缓存
    redis memcached

e. 读写分离
    主从热备份       主（写   增删改）  从（查）

f. 分库分表  水平分库分表
    http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table


 工作流程
1.  email
2.  git   gitlab  账号   rsa
3.  vpn  虚拟私有网络   阿里云 腾讯云    aws 亚马逊
4. 数据库
```

