---
title: 微信服务器验证
date: 2023/7/8 17:46:25
comments: true
tags: 
- 微信
- 服务器
categories: 
- 计算机
- 微信
---



## 微信公众号验证服务器地址的有效性

开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数：

![请求参数](../images/WeChat/valid_server.png)

开发者通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。

校验流程：

1. 将token、timestamp、nonce三个参数进行字典序排序
2. 将三个参数字符串拼接成一个字符串进行sha1加密
3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信

Python代码实现（以Flask框架为例）：

```python
# coding:utf-8

from flask import Flask, request, abort,make_response
import hashlib

Token = 'dwz123'
ENCODINGAESKEY = 'fyrtfnCqB6SpU2qSReCmx0fOyKHpBGtfSzOE6aKoIhP'

app = Flask(__name__)


@app.route('/')
def wechat():
    signature = request.args.get('signature')
    timestamp = request.args.get('timestamp')
    nonce = request.args.get('nonce')
    echostr = request.args.get('echostr')
    print(signature, timestamp, nonce, echostr)

    # 校验参数
    if not all([signature, timestamp, nonce, echostr]):
        abort(400)
    # 流程计算签名
    li = [timestamp, nonce, Token]
    # 排序
    li.sort()
    # 拼接字符串
    tmp_str = ''.join(li)
    # 使用utf8编译
    encoded_str = tmp_str.encode('utf-8')
    # 进行sha1加密
    sign = hashlib.sha1(encoded_str).hexdigest()
    # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器
    if sign == signature:
        return make_response(echostr)
    else:
        abort(400)
```



#### 查看端口占用情况

```
netstat -tunlp|grep 5000
```

#### 查看被占用端口的PID

```java
#   sudo lsof -i:5000
```

 **3、结束进程**

```java
#   sudo kill -9 633898
```

```
# copy到服务器
scp ./wechat.py ubuntu@122.51.202.183:~/
```

